- 简单总结：
实现sys_task_info 函数，使用户空间的程序能够查询当前任务的状态、系统调用次数和运行时间。
通过访问 TaskManager 的内部状态，返回当前运行任务状态/任务系统调用次数/任务总运行时间，并更新/记录当前任务使用的系统调用。
运行时间 time = 系统时间get_time_ms() - 当前任务上次记录的时间，返回系统调用时刻距离任务第一次被调度时刻的时长

- 简答作业

1.
RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0
[kernel] PageFault in application, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.


2.1
a0 在 __alltraps 函数中保存了当前的内核栈指针（sp），并传递给 trap_handler 作为上下文。
__restore 的两种主要使用情景分别是：1) 恢复用户态栈指针和寄存器，处理正常的中断和异常；2) 从内核返回到用户程序，恢复用户程序的状态。

2.2
sstatus：恢复用户态的中断使能状态。
sepc：恢复程序计数器，以便程序继续执行陷阱发生前的指令。
sscratch：恢复用户栈指针，确保用户栈在恢复后能正常工作。
这些寄存器的值对于确保用户程序能够在中断、异常或陷阱后恢复正常执行至关重要，特别是在内核和用户之间切换时。

2.3
x2（栈指针）：不恢复 x2 是因为栈指针的恢复是通过 sscratch 寄存器完成的，x2 本身在内核和用户态切换时通常由操作系统管理。
x4（线程指针）：x4（tp）通常在用户程序中不直接参与程序的控制流程，因此在恢复上下文时跳过 x4 是可行的，操作系统可能认为没有必要恢复该寄存器。
这种跳过的做法是为了优化寄存器恢复过程，并确保只有必要的寄存器得到恢复，减少不必要的操作。

2.4
sp 的值：在执行 `csrrw sp, sscratch, sp` 后，sp 寄存器将恢复为用户态的栈指针，这意味着栈指针现在指向用户栈的正确位置，用户程序可以继续执行并正常使用栈。
sscratch 的值：sscratch 中将保存内核态的栈指针（sp），为将来可能的上下文切换或栈操作提供支持。
这种操作是内核和用户态之间切换的关键步骤，确保栈指针在两者之间正确地传递和恢复。

2.5
在 __restore 中，sret 指令执行时发生了状态切换，导致处理器从内核态切换到用户态。该指令通过恢复 sstatus 和 sepc 寄存器的值，确保处理器恢复到用户态的正确状态（包括恢复程序计数器和栈指针等）。这使得用户程序能够在栈和状态恢复后继续执行。

2.6
sp 的意义：在执行 csrrw sp, sscratch, sp 后，sp 会被恢复为用户栈指针，这确保了用户程序能够正确地从内核态恢复执行，并继续使用用户态的栈。
sscratch 的意义：sscratch 中保存了内核栈指针（即 sp 执行前的值），它提供了在进行内核和用户态切换时栈指针的临时保存和恢复功能。
csrrw sp, sscratch, sp 指令通过交换 sp 和 sscratch 的值，确保了内核态和用户态之间的栈指针切换。在此过程中，sp 会指向用户态的栈，而 sscratch 会保存内核态的栈指针。

2.7
切换到超级态的指令是：
`csrrw sp, sscratch, sp`

荣誉准则

在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
无

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。